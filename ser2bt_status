#!/usr/bin/python3

# -*- coding:utf-8 -*-
import os
import socket
import struct  # Capture battary capacity
from waveshare_epd import epd2in13_V2
import time
from PIL import Image, ImageDraw, ImageFont  # Font handeling
import subprocess
import netifaces
import re
import smbus
import psutil  # Capture cpu and memory values
import logging

# Variable decleration:
pic_file = os.path.realpath(__file__)
picdir = os.path.join(os.path.dirname(os.path.dirname(pic_file)), 'pic')
host_name = socket.gethostname()  # define host_name
bus = smbus.SMBus(1)  # 0 = /dev/i2c-0 (port I2C0), 1 = /dev/i2c-1 (port I2C1)
min_bat_cap = 1  # setting minimum battery capacity before we'll shutdown.


def get_ssid():
    ps = subprocess.Popen(
         ['iwgetid'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT
       )
    try:
        output = subprocess.check_output(('grep', 'ESSID'), stdin=ps.stdout)
    except subprocess.CalledProcessError:
        # grep did not match any lines
        ssid = "Not Connected"
        return (ssid)
    output_ssid = output.decode(encoding='UTF-8')
    ssid = re.sub("wlan0 +[A-z]+:\"", "", output_ssid)
    ssid = re.sub("\"", "", ssid)
    return (ssid)


def readCapacity(bus):
    # "This function returns as a float the remaining capacity of the battery
    # connected to the Raspi UPS Hat via the pro$
    address = 0x36
    read = bus.read_word_data(address, 4)
    swapped = struct.unpack("<H", struct.pack(">H", read))[0]
    capacity = swapped/256
    return capacity

try:
    epd = epd2in13_V2.EPD()
    epd.init(epd.FULL_UPDATE)

    # Declare the fonts to be used:
    f_title_font18 = ImageFont.truetype("/usr/share/fonts/truetype/roboto/unhinted/RobotoTTF/Roboto-Bold.ttf", 18)
    f_var_spc_char_font18 = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", 18)
    f_title_font24 = ImageFont.truetype("/usr/share/fonts/truetype/roboto/unhinted/RobotoTTF/Roboto-Medium.ttf", 24)
    f_var_font18 = ImageFont.truetype("/usr/share/fonts/truetype/roboto/unhinted/RobotoTTF/Roboto-Medium.ttf", 18)
    f_top_line_font16 = ImageFont.truetype("/usr/share/fonts/truetype/roboto/unhinted/RobotoTTF/Roboto-Medium.ttf", 16)

    #Define frame size for e-ink display
    image = Image.new('1', (epd.height, epd.width), 255)  # 255: clear frame
    draw = ImageDraw.Draw(image)
    #Draw the non variablers to the to the screen.
    draw.text((0, 0), host_name, font=f_top_line_font16, fill=0)
    draw.line([(0, 17), (250, 17)], fill=0, width=2)
    draw.text((0, 20), 'Load: ', font=f_title_font18, fill=0)
    draw.text((53, 20), "CPU", font=f_var_font18, fill=0)
    draw.text((152, 20), "Mem", font=f_var_font18, fill=0)
    draw.text((0, 42), 'SSID: ', font=f_title_font18, file=0)
    draw.text((0, 63), 'IP Address: ', font=f_title_font18, fill=0)
    draw.text((0, 84), 'Services: ', font=f_title_font18, fill=0)
    draw.text((89, 84), 'BT', font=f_var_font18, fill=0)
    draw.text((131, 84), 'ser2net', font=f_var_font18, fill=0)
    draw.text((0, 105), 'TTYs: ', font=f_title_font18, fill=0)
    epd.displayPartBaseImage(epd.getbuffer(image)) #This is the command to actually place the above to the e-ink display.

    #Define the initial battery capacity.  This is just enough to get to the first iteration of the loop without dumping out.
    bat_cap = min_bat_cap+1
    while (bat_cap > min_bat_cap):
        # Grab initial information
        #This part grams the active network interface.
        try:
            iface = netifaces.gateways()['default'][netifaces.AF_INET][1]
        except Exception:
            iface = "NA"
        if iface != "NA":
            host_ip = netifaces.ifaddresses(iface)[netifaces.AF_INET][0]['addr']
        else:
            host_ip = "Not Connected"
         #This part grams the status of the various services that we need to monitor.
        bt_service_status = subprocess.Popen(['systemctl', 'is-active', 'rfcomm'], stdout=subprocess.PIPE).communicate()[0]
        bt_string_status = bt_service_status.decode(encoding='UTF-8')

        ser2net_service_status = subprocess.Popen(['systemctl', 'is-active', 'ser2net'], stdout=subprocess.PIPE).communicate()[0]
        ser2net_string_status = ser2net_service_status.decode(encoding='UTF-8')

        if "inactive" in bt_string_status:
            bt_status = "↓"  # down arrow
        else:
            bt_status = "↑"  # up arrow

        if "inactive" in ser2net_string_status:
            ser2net_status = "↓"  # down arrow
        else:
            ser2net_status = "↑"  # up arrow
        #This part grams the existing  wired serial ports.
        if os.path.exists("/dev/ttyUSB0"):
            wired_serial_port = "USB0"
        elif os.path.exists("/dev/ttyACM0"):
            wired_serial_port = "ACM0"
        else:
            wired_serial_port = "None"

        # Grabs existing bluetooth serial ports:
        if os.path.exists("/dev/rfcomm0"):
            bt_serial_port = "rfcomm0"
        else:
            bt_serial_port = "None"
        #Defines status for the various tty ports:
        if bt_serial_port == "None" and wired_serial_port == "None":
            bt_serial_status = "✖"
            wired_serial_status = "✖"
            full_tty_status = "No tty connections"
            full_tty_presence_flag = False # Nothing connected to any of the ttys
        elif bt_serial_port != "None" and wired_serial_port == "None":
            bt_serial_status = "✔"
            wired_serial_status = "✖"
            full_tty_status = ""
            full_tty_presence_flag = True # Something is connected to any of the ttys
        elif bt_serial_port == "None" and wired_serial_port != "None":
            bt_serial_status = "✖"
            wired_serial_status = "✔"
            full_tty_status = ""
            full_tty_presence_flag = True  # Something is connected to any of the ttys
        elif bt_serial_port != "None" and wired_serial_port != "None":
            bt_serial_status = "✔"
            wired_serial_status = "✔"
            full_tty_status = ""
            full_tty_presence_flag = True  # Something is connected to any of the ttys
        
        #This part grabs ssid, battery capacity, CPU and memory utilization:
        pi_ssid = get_ssid() #SSID
        bat_cap = int(readCapacity(bus)) #battery level
        bat_lvl = "Bat:"+str(bat_cap)+"%" #Formatted battery level
        p = str(psutil.cpu_percent())+"%" #CPU utlization
        svmem = psutil.virtual_memory() #memory
        mem = str(svmem.percent)+"%" #Formatted memory

        epd.init(epd.PART_UPDATE) #Initialize the partial screen
        #This block draws the rectangles, then places the refreshable text/variables into them.
        draw.rectangle((60, 0, 132, 15), fill=255)
        draw.text((60, 0), bat_lvl, font=f_top_line_font16, fill=0)
        draw.rectangle((133, 0, 250, 15), fill=255)
        draw.text((133, 0), time.strftime(
            '%D %H:%M'), font=f_top_line_font16, fill=0
           )
        draw.rectangle((90, 20, 151, 41), fill=255)
        draw.text((90, 20), p, font=f_var_font18, fill=0)
        draw.rectangle((197, 20, 250, 41), fill=255)
        draw.text((197, 20), mem, font=f_var_font18, fill=0)
        draw.rectangle((54, 42, 250, 62), fill=255)
        draw.text((54, 42), pi_ssid, font=f_var_font18, fill=0)
        draw.rectangle((103, 63, 250, 83), fill=255)
        draw.text((103, 63), host_ip, font=f_var_font18, fill=0)
        draw.rectangle((111, 84, 130, 104), fill=255)
        draw.text((111, 84), bt_status, font=f_var_spc_char_font18, fill=0)
        draw.rectangle((196, 84, 250, 104), fill=255)
        draw.text((196, 84), ser2net_status, font=f_var_spc_char_font18, fill=0)
        # setting up the dynamic parts of tty status
        # first, if nothing is connected, then just say that:
        draw.rectangle((57, 105, 250, 122), fill=255)
        #IF there are no tty connections, then display full_tty_status variable (saying nothing is attached.
        if full_tty_presence_flag is False:
            draw.text((57, 105), full_tty_status, font=f_var_font18, fill=0)
        else: #Otherwise, display the inidividual state of the ttys.
            draw.text((57, 105), bt_serial_port, font=f_var_font18, fill=0)
            draw.text((138, 105), bt_serial_status, font=f_var_spc_char_font18, fill=0)
            draw.text((161, 105), wired_serial_port, font=f_var_font18, fill=0)
            draw.text((206, 105), wired_serial_status, font=f_var_spc_char_font18, fill=0)
        epd.displayPartial(epd.getbuffer(image)) #update the screeen to actually print the above to the e-ink display.
        time.sleep(5)
# End of while bat_cap > 2 loop...

# if the bat_cap is less that min_bat_cap, then bail out of the loop, and follow the remaining code to shutdown.
    term_image = Image.new('1', (epd.height, epd.width), 255)  # 255: clear frame
    term_draw = ImageDraw.Draw(term_image)
    epd.init(epd.FULL_UPDATE)
#    epd.Clear(0xFF)
    term_draw.text((35, 20), 'Shutting Down!', font=f_title_font24, fill=0)
    term_draw.text((3, 50), 'Due to Critical Battary level ', font=f_title_font18, fill=0)
    epd.display(epd.getbuffer(term_image))
    logging.info("Shutting down - battary has reached critical level")
    logging.info("Battary is: "+str(bat_cap)+"%")
    time.sleep(5)
    epd.init(epd.FULL_UPDATE)
    exit_image=Image.new('1', (epd.height, epd.width), 255)  # 255: clear the frame
    exit_draw=ImageDraw.Draw(exit_image)
    exit_draw.text((43, 20), 'This device', font=f_title_font24, fill=0)
    exit_draw.text((48, 50), 'Has been shutdown ', font=f_title_font18, fill=0)
    epd.display(epd.getbuffer(exit_image))
    epd2in13_V2.epdconfig.module_exit()
    os.system("shutdown -P now")
    exit()

except (KeyboardInterrupt, SystemExit):
    term_image = Image.new('1', (epd.height, epd.width), 255)  # 255: clear the frame
    term_draw = ImageDraw.Draw(term_image)
    print ("application is closing\n")
    epd.init(epd.FULL_UPDATE)
    term_draw.text((6, 20), 'Exiting ser2bt_status', font=f_title_font24, fill=0)
    term_draw.text((63, 50), 'Due to SIGINT ', font=f_title_font18, fill=0)
    epd.display(epd.getbuffer(term_image))
    time.sleep(5)
    epd.init(epd.FULL_UPDATE)
    exit_image = Image.new('1', (epd.height, epd.width), 255)  # 255: clear the frame
    exit_draw = ImageDraw.Draw(exit_image)
    exit_draw.text((6, 20), 'ser2bt_status service', font=f_title_font24, fill=0)
    exit_draw.text((48, 50), 'Has been stopped ', font=f_title_font18, fill=0)
    epd.display(epd.getbuffer(exit_image))
    epd2in13_V2.epdconfig.module_exit()
    exit()
